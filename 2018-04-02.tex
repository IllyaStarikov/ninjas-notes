\section{2018-04-02}

\subsection{Commonality of Implementation}

\subsubsection{Implementation bases}

In chapter 9, we focused on common behavior and that lead to virtual functions and interface bases. An interface had no state variables.

Now our goal is to deal with repeated code. We will now use extension by public inheritance to avoid the unnecessary replication of code.

Recall from chapter 4 that we extended the functionality of the \cpp{Array} class to become the \cpp{CheckedArray}. We do the same thing but in a different way.

\begin{lstlisting}[language=C++]
class CheckedArray : public Array {
  public:
    CheckedArray(int n);
    CheckedArray();
    float& operator[](int i);
    CheckedArray& operator=(float f);
    class SubscriptErr { /* ... */ }
};

//as a reminder
class Array {
  public:
    Array(int n);
    Array();
    Array(const Array& a);
    ~Array();
    float& operator[](int i);
    Array& operator=(const Array& s);
    Array operator=(float);
    void setSize(int n);

  private:
    int numElts;
    float* ptrToData;
    void copy(/* ... */);
};
\end{lstlisting}

Notice that we have \underline{NO} virtual functions and the base has data (member variables). This is \underline{NOT} an interface base. Notice also that it provides implementation. This base class is called an \underline{implementation base}. Any instance of a derived class contains an instance of the base called the \underline{base subobject}. 

Each member of the base is inherited by the derived class except:

\begin{itemize}
  \item constructors
  \item destructors
  \item copy assignment
\end{itemize}

Any function that is declared in the derived class that has the same name is said to hide that which is in the base. Thus, the \cpp{CheckedArray} class has its own projection operator (\cpp{[]}) and its own assignment operator (\cpp{=}), along with constructors.

Let's write the \cpp{[]} operator:

\begin{lstlisting}[language=C++]
float& CheckedArray::operator[](int i) {
  if (i < 0 || i >= numElts) throw SubscriptError();

  return Array::operator[](i); //using the functionality of the base
}
\end{lstlisting}

Again, unless defined for the derived class, the constructors and destructors of will automatically be generated by the compiler. A derived class must provide for construction of any subobject in addition to any new members. For example:

\begin{lstlisting}[language=C++]
CheckedArray::CheckedArray(int n) : Array(n) { }
\end{lstlisting}

The \cpp{Array(n)} is called  a \underline{base initializer}.

Of course, it is best to provide \underline{default construction}...

\begin{itemize}
  \item ...if you want an array of this particular kind-o-object
  \item ...the existence of any other constructor will suppress the automatic default constructor
\end{itemize}

Also, if C++ generates its own copy constructors, it will call the base class version. This is also true for the copy assignment operator. Remember that the assignment operators are not inherited.

\begin{lstlisting}[language=C++]
CheckedArray& CheckedArray::operator=(float f) {
  Array::operator=(f);
  return *this;
}
\end{lstlisting}

Clients: Derived class objects can be passed to pointers and references to the base class type. But if so, the base \underline{class functionality} applies.

\begin{lstlisting}[language=C++]
float maxElt(Array& a) {
  //operator[] used...
  return max;
}
\end{lstlisting}

What \cpp{operator[]} is used? Checked or unchecked? Its the base version (unchecked) that is used.